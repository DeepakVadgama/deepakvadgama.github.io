I"g<h2 id="introduction">Introduction</h2>

<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/DelayQueue.html">DelayQueue</a> is used as a work-queue for storing scheduled tasks in <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a>.</p>

<p>Its core logic is simple: The elements are stored in a priority queue, sorted based on their scheduled time (earliest to expire is at head of the queue). During poll/take operations, the head element can be returned only if/when it’s scheduled time has expired.</p>

<p>Though, this can potentially mean multiple threads synchronizing on the head element causing overhead. 
This is resolved using <code class="highlighter-rouge">Leader-Follower</code> pattern which is improvement on <code class="highlighter-rouge">Half-Sync/Half-Async</code> pattern. 
This makes the <code class="highlighter-rouge">DelayedQueue</code> implementation quite fascinating.</p>

<p>The source code for <code class="highlighter-rouge">DelayQueue</code> can be found <a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/DelayQueue.java?view=markup">here</a>. Leader-Follower paper can be found <a href="http://www.cs.wustl.edu/%7Eschmidt/PDF/lf.pdf">here</a></p>

<h2 id="leader-follower-pattern">Leader-Follower pattern</h2>

<p>Suppose there is an scheduled task at the head of the queue with timeout of 5 seconds. All the threads wanting 
to take/poll the element have to sleep (aka timed-wait) for 5 seconds. Once 5 seconds are over and element 
is eligible to be taken out of the queue, all threads will vie for same element.</p>

<p>Instead, one thread is chosen as leader at the beginning, and only that threads awaits 5 seconds.
All other threads will wait on a <code class="highlighter-rouge">condition</code>. Once 5 seconds are over, the leader will take the element, 
and signal the <code class="highlighter-rouge">condition</code> so that someone else can become the leader and get the next element in the queue.</p>

<figure>
    <a href="https://deepakvadgama.com/images/blog/leader_follower_pattern.png" data-lightbox="image-1"><img src="https://deepakvadgama.com/images/blog/leader_follower_pattern.png" /></a>
</figure>

<p>Steps:</p>

<ol>
  <li>Leader awaits for the head element to expire</li>
  <li>All other threads await on a condition</li>
  <li>Leader takes the element after expiry &amp; signals the condition</li>
  <li>One of the other threads becomes the new leader</li>
</ol>

<p>The above algorithm should become clearer as we walk-through the source code below.</p>

<h2 id="delayed-interface">Delayed interface</h2>

<p><code class="highlighter-rouge">DelayedQueue</code> stores instances of <code class="highlighter-rouge">Delayed</code> instances.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Delayed</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Delayed</span><span class="o">&gt;</span> <span class="o">{</span>

     <span class="c1">// return the remaining delay</span>
     <span class="c1">// if value &lt; 0, the delay has already elapsed</span>
    <span class="kt">long</span> <span class="nf">getDelay</span><span class="o">(</span><span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// sample implementation (partial code)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyDelayedTask</span> <span class="kd">implements</span> <span class="nc">Delayed</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getDelay</span><span class="o">(</span><span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">unit</span><span class="o">.</span><span class="na">convert</span><span class="o">(</span><span class="n">time</span> <span class="o">-</span> <span class="nc">System</span><span class="o">.</span><span class="na">nanoTime</span><span class="o">(),</span> <span class="no">NANOSECONDS</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="nc">Delayed</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="c1">// check remaining time</span>
        <span class="kt">long</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">time</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="na">time</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            
        <span class="c1">// in case both have same expiry</span>
        <span class="c1">// check for which arrived earlier (FIFO)</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">sequenceNumber</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="na">sequenceNumber</span><span class="o">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="initialization">Initialization</h2>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="c1">// lock for the synchronization</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="kd">transient</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
  
 <span class="c1">// queue to store all delayed elements (sorted by expiry/delay time remaining)</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;();</span>

 <span class="c1">// reference to leader thread</span>
 <span class="kd">private</span> <span class="nc">Thread</span> <span class="n">leader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
  
 <span class="c1">// condition for other threads to wait on</span>
 <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Condition</span> <span class="n">available</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
 </code></pre></figure>

<h2 id="add--offer">Add / Offer</h2>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">offer</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
        
            <span class="c1">// add element to the queue</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            
            <span class="c1">// if this new element is new head of the queue </span>
            <span class="c1">// i.e. having shorter expiry time</span>
            <span class="c1">// reset leader and signal condition </span>
            <span class="k">if</span> <span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">leader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                <span class="n">available</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span></code></pre></figure>

<h2 id="poll">Poll</h2>

<p>Get the element at head of the queue if expired else return null.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="no">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
        
            <span class="c1">// get head of the queue</span>
            <span class="no">E</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            
            <span class="c1">// if there are no elements or if none have expired yet return null </span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">first</span><span class="o">.</span><span class="na">getDelay</span><span class="o">(</span><span class="no">NANOSECONDS</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    </code></pre></figure>

<h2 id="take">Take</h2>

<p>Get the element at head of the queue if expired else block until expiry.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="no">E</span> <span class="nf">take</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
    
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        
            <span class="c1">// 1. get head element </span>
            <span class="no">E</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            
            <span class="c1">// 2. if there is no element, wait for the signal</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
                <span class="n">available</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
            <span class="k">else</span> <span class="o">{</span>
            
                <span class="c1">// 3. if first element has expired return the element</span>
                <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">getDelay</span><span class="o">(</span><span class="no">NANOSECONDS</span><span class="o">);</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    
                <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// don't retain ref while waiting</span>
                
                <span class="c1">// 4. if leader is already chosen, wait for the signal</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">leader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">available</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
                <span class="k">else</span> <span class="o">{</span>
                
                    <span class="c1">// 5. set this thread as the leader </span>
                    <span class="nc">Thread</span> <span class="n">thisThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                    <span class="n">leader</span> <span class="o">=</span> <span class="n">thisThread</span><span class="o">;</span>
                    
                    <span class="c1">// 6. wait for the element to expire</span>
                    <span class="k">try</span> <span class="o">{</span>
                        <span class="n">available</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">delay</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    
                        <span class="c1">// 7. once expired, reset the leader</span>
                        <span class="c1">// run through for loop, and return the element</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">leader</span> <span class="o">==</span> <span class="n">thisThread</span><span class="o">)</span>
                            <span class="n">leader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    
        <span class="c1">// 8. if leader is reset and there are still elements in the queue</span>
        <span class="c1">// signal the other waiting threads</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leader</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">available</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="poll-1">Poll</h2>

<p>Get element at head of the queue if expired else wait for given duration or element’s expiry whichever is shorter.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="no">E</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">nanos</span> <span class="o">=</span> <span class="n">unit</span><span class="o">.</span><span class="na">toNanos</span><span class="o">(</span><span class="n">timeout</span><span class="o">);</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        
            <span class="c1">// 1. get head element </span>
            <span class="no">E</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">();</span>
            
            <span class="k">if</span> <span class="o">(</span><span class="n">first</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 2. if there is no element, and timeout has occurred, return null</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                
                <span class="c1">// 3. if there is no element, wait on condition, </span>
                <span class="c1">// but, only until timeout or signal whichever is first</span>
                <span class="k">else</span>
                    <span class="n">nanos</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            
                <span class="c1">// 4. get expiry of the head element</span>
                <span class="kt">long</span> <span class="n">delay</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="na">getDelay</span><span class="o">(</span><span class="no">NANOSECONDS</span><span class="o">);</span>
                
                <span class="c1">// 5. if expired return the element</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    
                <span class="c1">// 6. if timeout has occurred return null</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                    
                <span class="n">first</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// don't retain ref while waiting</span>
                
                <span class="c1">// 7. if given timeout is less than head element expiry</span>
                <span class="c1">// then wait for condition but only for maximum of given timeout</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nanos</span> <span class="o">&lt;</span> <span class="n">delay</span> <span class="o">||</span> <span class="n">leader</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="n">nanos</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">nanos</span><span class="o">);</span>
                <span class="k">else</span> <span class="o">{</span>
                
                    <span class="c1">// 8. if given timeout is more than element's expiry &amp; there is no leader</span>
                    <span class="c1">// set current thread as the leader </span>
                    <span class="nc">Thread</span> <span class="n">thisThread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
                    <span class="n">leader</span> <span class="o">=</span> <span class="n">thisThread</span><span class="o">;</span>
                    <span class="k">try</span> <span class="o">{</span>
                    
                        <span class="c1">// 9. wait until first element expires</span>
                        <span class="kt">long</span> <span class="n">timeLeft</span> <span class="o">=</span> <span class="n">available</span><span class="o">.</span><span class="na">awaitNanos</span><span class="o">(</span><span class="n">delay</span><span class="o">);</span>
                        
                        <span class="c1">// 10. update the timeout accordingly</span>
                        <span class="n">nanos</span> <span class="o">-=</span> <span class="n">delay</span> <span class="o">-</span> <span class="n">timeLeft</span><span class="o">;</span>
                        
                    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                    
                        <span class="c1">// 11. once expired, reset the leader</span>
                        <span class="c1">// run through for loop, and repeat</span>
                        <span class="k">if</span> <span class="o">(</span><span class="n">leader</span> <span class="o">==</span> <span class="n">thisThread</span><span class="o">)</span>
                            <span class="n">leader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    
        <span class="c1">// 12. if leader is reset and there are still elements in the queue</span>
        <span class="c1">// signal the other waiting threads</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">leader</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">available</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p>We skipped few methods, but even then this is one of the shorter source codes we’ve seen so far. I was initially 
lost as to why we needed a leader and a condition. Going through the paper helped.</p>

<p>Hit me in the up in the comments for any queries or concerns.</p>
:ET