I"¦<p>I have been working on a federated search model since 2 years until March 2019, where for every query, we make API calls to all search providers,
aggregate the results and send back the response. Though, it sounds very limited, we were able to add layers of functionality on top to make it better for our users.</p>

<h3 id="the-product">The Product</h3>

<ul>
  <li>Initially our team owned both the UI (Web portal) and backend for search.</li>
  <li>Eventually we exposed search as a service (API)</li>
  <li>API has been adopted across 4 channels (Web, Mobile and 2 Desktop applications).</li>
</ul>

<h3 id="basic-flow">Basic flow</h3>

<p>When Search API is called, user is authenticated. For each provider entitlements are checked if user is allowed to call the providers. 
All entitled providersâ€™ search APIs are called in parallel, with a timeout of 2 seconds. Returned results are converted
to JSON format, aggregated and returned to the user.</p>

<h3 id="slow-provider-problem">Slow provider problem</h3>

<ul>
  <li>Normal execution - Create 7 Runnable tasks, a countdown latch with timeout of 2 seconds and submit all tasks. Aggregate and return results arrived within 2 seconds. Average latency across providers was 300ms, so we hardly breached 2 second barrier.</li>
  <li>Slow provider - Sometimes a provider responds slow for a period of time. One of the 7 tasks takes more than 2 seconds to complete. Individual search query is not affected as countdown latch breaks and partial results are returned.</li>
  <li>But, if search rate is high, tasks for slow provider eventually occupy the queue and thus, all threads.</li>
  <li>Such tasks are short-ciruited if result for that search is already returned.</li>
  <li>This is very similar to circuit breaker pattern used for fault-tolerant microservices.</li>
  <li>One API client which wanted the provider result irrespective of time-taken used API parameter of timeout (increasing it to 10). This had potential to impact our
servlet thread-pool but after monitoring for a few days decided against putting extra precautions.</li>
</ul>

<h3 id="search-api">Search API</h3>

<ul>
  <li>License key for onboarded users (plan was to use it for rate-limiting &amp; metrics)</li>
  <li>API allowed specifying providers, max result count &amp; custom timeouts</li>
  <li>Slow providers not included by default. Could be explicitly added to the request.</li>
  <li>JSON response contained custom schema structure for each provider.</li>
</ul>

<h3 id="entitlements">Entitlements</h3>

<ul>
  <li>Authentication was done by an in-house service (available as Apache plugin &amp; Cloud Foundry services).</li>
  <li>Some providers (legacy systems) used their own userids. These ids were fetched via an API and cached in Solr.</li>
  <li>Authorization of providers for each user was done using entitlements service and cached for 4 hours.</li>
</ul>

<h3 id="configuration--feature-flags">Configuration &amp; Feature flags</h3>

<ul>
  <li>All the features are kept behind a feature flag</li>
  <li>It helped immensely during a production bug which was causing too many calls to a legacy service</li>
  <li>Disabled the feature by flipping the flag &amp; avoided emergency bug fix deploy.</li>
  <li>New config is fetched every 10 minutes.</li>
  <li>Protected (admin only) API to force flush the cache &amp; reload.</li>
</ul>

<h3 id="recent-queries">Recent Queries</h3>

<ul>
  <li>API to return 5 recent search queries done by the user</li>
  <li>Stored in Solr, and least recent removed simultaneously.</li>
  <li>Solr, technically not the right technology for this but it was available to us as a managed service</li>
</ul>

<h3 id="recent-navigations">Recent Navigations</h3>

<ul>
  <li>API to return 5 recent search results clicked (navigated to) by the user</li>
  <li>JSON for the result stored on every result click in Solr</li>
  <li>If more than 5 results present for the user, least recent removed simultaneously.</li>
  <li>Solr, technically not the right technology for this but it was available to us as a managed service</li>
  <li>Once a day, all results checked for entitlements.</li>
  <li>Entitlement check tasks (users entitlements already available in cache)</li>
  <li>For one provider (w/ fine-grained entitlement), API call was made to check entitlement (detailed below).</li>
</ul>

<h3 id="trending-navigations">Trending Navigations</h3>

<ul>
  <li>API to expose top 5 trending results (entitled to be seen by the user)</li>
  <li>Co-relational to news/market events</li>
  <li>Top 100 trending items retrieved from metrics (for last 7 days)</li>
  <li>When API hit for a user, each result/item checked for entitlement in batches of 5 (ExecutorService)</li>
  <li>Trade off between eager load (too much memory use) vs lazy load (first time delay in response as results are not cached)</li>
  <li>5 results cached in Solr against the userid</li>
  <li>Flushed every day, and new top 100 retrieved</li>
</ul>

<h3 id="auto-suggest--synonyms">Auto-suggest / Synonyms</h3>

<ul>
  <li>Ability to suggest search queries to the user.</li>
  <li>Used Solrâ€™s suggest API.</li>
  <li>Populated with previous searches by the users (extracted from metrics).</li>
  <li>Also, added reference data (Analyst, Companies, Tickers, Currencies, Countries etc.) to it.</li>
</ul>

<h3 id="fine-grained-entitlements">Fine grained entitlements</h3>

<ul>
  <li>One data provider maintained its own set of fine-grained entitlements (not available to us).</li>
  <li>This limited the trending and recent navigation functionality, where user entitlements had to be checked at regular intervals.</li>
  <li>Provider API endpoint was hit for entitlement checks, where the response was matched with the cached result. If it matched, that meant user still had the entitlement for that item.</li>
</ul>

<h3 id="cloud-foundry">Cloud Foundry</h3>

<p>2 separate replicas of architecture (with common Solr/DB)</p>

<p><em>Old</em></p>
<ul>
  <li>Apache (w/ plugin for authentication)</li>
  <li>Tomcat (4 instances) on VSI boxes</li>
  <li>Used only for web portal</li>
</ul>

<p><em>New</em></p>
<ul>
  <li>3 new data sensitive providers onboarded. Had to replicate architecture in more secure zone.</li>
  <li>Chose in-house Cloud Foundry. Our application was already stateless and adhered to 12-factor, thus required minimal changes to the code-base.</li>
  <li>9 Cloud Foundry instances across 3 regions (9 AZs)</li>
  <li>Global Load Balancer with active health checks.</li>
  <li>Used for Search as a service API</li>
</ul>

<h3 id="rest-of-the-stack">Rest of the stack</h3>

<ul>
  <li>Maven multi-module to ensure separation of code connecting to data sensitive providers. Each build creates 2 artifacts one for each architecture copy.</li>
  <li>Jenkins to build and deploy artifacts (one using in-house model other using cloud foundry push command)</li>
  <li>Splunk to view the logs</li>
  <li>Metrics service to store the events</li>
  <li>Retrofit for HTTP calls</li>
  <li>Solr for caching</li>
</ul>

:ET