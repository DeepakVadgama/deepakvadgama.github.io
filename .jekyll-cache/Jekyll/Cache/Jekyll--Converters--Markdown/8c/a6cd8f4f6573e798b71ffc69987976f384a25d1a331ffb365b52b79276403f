I"©Í<h2 id="introduction">Introduction</h2>

<p>Following the <a href="https://deepakvadgama.com/blog/java-hashmap-internals/">fun exercise</a> to understand JDKâ€™s HashMap implementation code, I decided to walk-through the code 
for <a href="https://github.com/openjdk-mirror/jdk/tree/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent">ThreadPool executor classes</a>.</p>

<p>This code walk through is not sequential nor atomic (per method). 
We will try to pick and choose code which will get us a working version of executors. 
In each subsequent step, we will add one feature or address a problem.
Thus more complicated aspects like locking are discussed in the latter half.</p>

<h2 id="table-of-contents">Table of contents</h2>
<ul>
  <li><a href="#core">Core</a>
    <ul>
      <li><a href="#adding-tasks-and-new-threads">Adding tasks and new threads</a></li>
      <li><a href="#worker-threads-creation">Worker threads creation</a></li>
      <li><a href="#worker-threads-executing-tasks">Worker Threads executing tasks</a></li>
      <li><a href="#reduce-or-maintain-pool-size-post-task-completion">Reduce or Maintain pool size post-task-completion</a></li>
      <li><a href="#reduce-or-maintain-pool-size-pre-task-acceptance">Reduce or Maintain pool size pre-task-acceptance</a></li>
      <li><a href="#rejection-handlers">Rejection handlers</a></li>
    </ul>
  </li>
  <li><a href="#locking">Locking</a>
    <ul>
      <li><a href="#using-a-common-main-lock">Using a common main lock</a></li>
      <li><a href="#using-ctl-lock">Using ctl lock</a></li>
      <li><a href="#worker-locks">Worker locks</a></li>
    </ul>
  </li>
  <li><a href="#executor-shutdown--with-states-">Executor shutdown (with states)</a></li>
  <li><a href="#thread-interrupts">Thread Interrupts</a></li>
  <li><a href="#default-thread-factory--executors-">Default thread factory (Executors)</a></li>
  <li><a href="#types-of-executors">Types of executors</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="core">Core</h2>

<p>Instead of starting from constructors, lets start from the heart of Executors i.e. running a submitted task.
The basic idea is, tasks submitted are added to a queue, and threads keep picking tasks from that queue and execute them. 
Based on the configuration and current number of threads, this process is slightly tweaked.</p>

<h3 id="adding-tasks-and-new-threads">Adding tasks and new threads</h3>

<p>The tasks are assigned to the threads in 3 ways</p>

<ul>
  <li>If thread pool count &lt; core pool size, then create new worker thread and assign task to it.</li>
  <li>If thread pool count &gt;= core pool size, add task to the queue (will be retrieved by worker thread later)</li>
  <li>If task queue is bounded and full, then add create new worker thread and assign task to it.</li>
</ul>

<p>The second argument to addWorker method just indicates the pool-size (true = corePoolSize, and false = maxPoolSize). 
  So if number of threads are more than that size, new worker thread is not added, and method returns false.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for execute method</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// if no task submitted, return NPE</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
        
    <span class="c1">// if number of threads in the pool is less than core-pool-size, </span>
    <span class="c1">// then create a new worker thread and assign the new task to it</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
            <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// else, add task to the queue</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
        <span class="o">....</span>
    <span class="o">}</span>
    
    <span class="c1">// else create new thread and assign task to it</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span> <span class="c1">// pool-size is &gt;= core-pool-size</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>   <span class="c1">// If pool-size &gt;= max-pool-size</span>
<span class="o">}</span></code></pre></figure>

<h3 id="worker-threads-creation">Worker threads creation</h3>

<p>In books and tutorials related to Java Threads, we are shown a new Thread instance is generally created by passing argument of a Runnable. In this class, the Runnable (Worker) creates its own thread from the thread-factory (see constructor) and holds a reference to the same.</p>

<p>Once the worker is created, it is added to set of workers, representing the thread-pool. The worker is then started 
and its status is returned to the caller.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for addWorker method</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">addWorker</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">core</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">workerAdded</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="nc">Worker</span> <span class="n">w</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
    
        <span class="c1">// 1. create a new worker with given task</span>
        <span class="n">w</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Worker</span><span class="o">(</span><span class="n">firstTask</span><span class="o">);</span>
        <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">workers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>  <span class="c1">// removed surround lock code for brevity</span>
            <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
            <span class="n">workerStarted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">workerStarted</span><span class="o">)</span>
            <span class="n">addWorkerFailed</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// 3. Return started status</span>
    <span class="k">return</span> <span class="n">workerStarted</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// partial code for Worker class</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Worker</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
        
    <span class="c1">// Thread this worker is running in. Null if factory fails.</span>
    <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">thread</span><span class="o">;</span>
    
    <span class="c1">// Initial task to run. Possibly null.</span>
    <span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">;</span>
    
    <span class="nc">Worker</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">firstTask</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// the command (task) passed in section above</span>
        <span class="k">this</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="n">firstTask</span><span class="o">;</span>
        
        <span class="c1">// create thread from factory</span>
        <span class="k">this</span><span class="o">.</span><span class="na">thread</span> <span class="o">=</span> <span class="n">getThreadFactory</span><span class="o">().</span><span class="na">newThread</span><span class="o">(</span><span class="k">this</span><span class="o">);</span> 
    <span class="o">}</span>

    <span class="c1">// Delegates main run loop to outer runWorker </span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">runWorker</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="worker-threads-executing-tasks">Worker Threads executing tasks</h3>

<p>As seen in code earlier, the run method of a Worker calls method runWorker. 
 This method keeps taking tasks from the queue and calls run() for each task explicitly.</p>

<p>Note: Process of getting tasks from queue involves more checks which we will see later.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for runWorker method</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 1. get first task if any</span>
    <span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span><span class="o">;</span>
    <span class="n">w</span><span class="o">.</span><span class="na">firstTask</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    
    <span class="c1">// 2. run firstTask if present or keep getting tasks from the queue, and run them</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">task</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">getTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span> <span class="c1">// 3. call run method explicitly</span>
        
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// partial code for getTask </span>
<span class="kd">private</span> <span class="nc">Runnable</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span> 

    <span class="c1">// get new task to execute from queue, block if unavailable. </span>
    <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<h3 id="reduce-or-maintain-pool-size-post-task-completion">Reduce or Maintain pool size post-task-completion</h3>

<p>When the worker runs out of tasks to execute (queue is empty), then it calls processWorkerExit, 
which can reduce the size of the pool or can create new worker thread.
 New worker thread is created based on few conditions</p>

<ul>
  <li>If core threads are allowed to timeout, and there are no pending tasks, worker is not replaced.</li>
  <li>If current count of workers is greater than minimum required (corePoolSize), worker is not replaced.</li>
  <li>If both conditions above fail, then new worker is created.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for runWorker method</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">task</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">task</span> <span class="o">=</span> <span class="n">getTask</span><span class="o">())</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
            <span class="n">task</span><span class="o">.</span><span class="na">run</span><span class="o">();</span> 
        <span class="o">}</span>
        <span class="n">completedAbruptly</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// if there are no more tasks to run, or if there is exception, exit.</span>
        <span class="n">processWorkerExit</span><span class="o">(</span><span class="n">w</span><span class="o">,</span> <span class="n">completedAbruptly</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// partial code for processWorkerExit</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">processWorkerExit</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// 1. If abrupt, then workerCount wasn't adjusted</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">completedAbruptly</span><span class="o">)</span> 
        <span class="n">decrementWorkerCount</span><span class="o">();</span>

    <span class="c1">// 2. maintain completed task count</span>
    <span class="n">completedTaskCount</span> <span class="o">+=</span> <span class="n">w</span><span class="o">.</span><span class="na">completedTasks</span><span class="o">;</span> 
    <span class="n">workers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">w</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(!</span><span class="n">completedAbruptly</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="c1">// 3. Check if worker thread needs to be replaced </span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">corePoolSize</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
            <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            
        <span class="c1">// 4. replacement not needed</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="o">)</span>
            <span class="k">return</span><span class="o">;</span> 
    <span class="o">}</span>
    
    <span class="c1">// 5. replace worker </span>
    <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<h3 id="reduce-or-maintain-pool-size-pre-task-acceptance">Reduce or Maintain pool size pre-task-acceptance</h3>

<p>While getting new tasks to execute, we may need to stop the worker based on few more conditions.</p>

<ul>
  <li>If shutdown is requested for the executor</li>
  <li>If there are no tasks available and there is atleast 1 thread to execute tasks submitted later</li>
  <li>If there are more worker threads than maximum allowed</li>
</ul>

<p>The polling for new task, is either blocking or timeout-based depending on the thread-count (if its more than core pool size) or allowCoreThreadTimeOut (if core threads are allowed to timeout and thus reduce in number).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for getTask </span>
<span class="kd">private</span> <span class="nc">Runnable</span> <span class="nf">getTask</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// Did the last poll() time out?</span>

    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="c1">// Check if queue empty only if necessary.</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&gt;=</span> <span class="no">SHUTDOWN</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">rs</span> <span class="o">&gt;=</span> <span class="no">STOP</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">decrementWorkerCount</span><span class="o">();</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">wc</span> <span class="o">=</span> <span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>

        <span class="c1">// Are workers subject to culling?</span>
        <span class="kt">boolean</span> <span class="n">timed</span> <span class="o">=</span> <span class="n">allowCoreThreadTimeOut</span> <span class="o">||</span> <span class="n">wc</span> <span class="o">&gt;</span> <span class="n">corePoolSize</span><span class="o">;</span>

        <span class="c1">// return null if thread count more than maximum, or thread timed-out polling task</span>
        <span class="c1">// and if there are no tasks to execute and more than one thread available</span>
        <span class="k">if</span> <span class="o">((</span><span class="n">wc</span> <span class="o">&gt;</span> <span class="n">maximumPoolSize</span> <span class="o">||</span> <span class="o">(</span><span class="n">timed</span> <span class="o">&amp;&amp;</span> <span class="n">timedOut</span><span class="o">))</span>
            <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">wc</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">compareAndDecrementWorkerCount</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">continue</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// timeout poll if coreThreadTimeOut is allowed or thread count &gt; corePoolSize</span>
            <span class="nc">Runnable</span> <span class="n">r</span> <span class="o">=</span> <span class="n">timed</span> <span class="o">?</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">keepAliveTime</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">NANOSECONDS</span><span class="o">)</span> <span class="o">:</span>
                <span class="n">workQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="k">return</span> <span class="n">r</span><span class="o">;</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">retry</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">timedOut</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="rejection-handlers">Rejection handlers</h3>

<p>The tasks which are rejected (due to queue full, or poolSize being full) are handled using rejectionHandlers</p>

<ul>
  <li>Caller runs Policy - calls the run method with current context (i.e. thread of the caller itself)</li>
  <li>Abort Policy (default) - throw RejectedExecutionExcpetion</li>
  <li>Discard Policy - do nothing (swallows the fact that it was unable to run the task)</li>
  <li>Discard Oldest Policy - removes first task from queue (oldest), and enqueues the new task</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for execute</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// reject if executor is not running anymore (shutdown requested)</span>
    <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        
    <span class="c1">// reject if task queue is full and cannot add new worker </span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="kt">void</span> <span class="nf">reject</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">handler</span><span class="o">.</span><span class="na">rejectedExecution</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="k">this</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// caller runs policy</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CallerRunsPolicy</span> <span class="kd">implements</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>

    <span class="c1">// run task (runnable) in the caller thread</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">e</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">r</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// abort policy - default</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">AbortPolicy</span> <span class="kd">implements</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>
    
    <span class="c1">// throw rejected exception</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RejectedExecutionException</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">r</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span>
                                             <span class="s">" rejected from "</span> <span class="o">+</span>
                                             <span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// discard policy</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DiscardPolicy</span> <span class="kd">implements</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>

    <span class="c1">// do nothing</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// discard oldest policy</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">DiscardOldestPolicy</span> <span class="kd">implements</span> <span class="nc">RejectedExecutionHandler</span> <span class="o">{</span>

    <span class="c1">// get first task from the queue (which will be the oldest task available)</span>
    <span class="c1">// then submit this particular task</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rejectedExecution</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">,</span> <span class="nc">ThreadPoolExecutor</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">e</span><span class="o">.</span><span class="na">isShutdown</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">getQueue</span><span class="o">().</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">r</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="locking">Locking</h2>

<h3 id="using-a-common-main-lock">Using a common main lock</h3>

<p>Most of the methods in this class use a ReentrantLock called mainLock to perform synchronized access 
to the common state.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
<span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="c1">// ... code ... </span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<h3 id="using-ctl-lock">Using ctl lock</h3>

<p>This class uses an AtomicInteger to maintain combined state of 2 fields</p>

<ul>
  <li>Number of worker threads (29 bits)</li>
  <li>Run state of the executor (2 bits)</li>
</ul>

<p>Updating of the worker thread count and the state of the executor is then performed using compareAndSet operations.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">ctl</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">ctlOf</span><span class="o">(</span><span class="no">RUNNING</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">COUNT_BITS</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">SIZE</span> <span class="o">-</span> <span class="mi">3</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">CAPACITY</span>   <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

<span class="c1">// runState is stored in the high-order bits</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>

<span class="c1">// Packing and unpacking ctl</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">runStateOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>     <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="o">~</span><span class="no">CAPACITY</span><span class="o">;</span> <span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">workerCountOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">c</span><span class="o">)</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="no">CAPACITY</span><span class="o">;</span> <span class="o">}</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ctlOf</span><span class="o">(</span><span class="kt">int</span> <span class="n">rs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">wc</span><span class="o">)</span> <span class="o">{</span> <span class="k">return</span> <span class="n">rs</span> <span class="o">|</span> <span class="n">wc</span><span class="o">;</span> <span class="o">}</span>

<span class="c1">// Example code of updating state and thread count</span>
<span class="n">ctl</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">ctlOf</span><span class="o">(</span><span class="no">TIDYING</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span></code></pre></figure>

<h3 id="worker-locks">Worker locks</h3>

<p>Worker class extends AbstractQueuedSynchronizer to gain locking mechanism. 
Many of the JDK Concurrent utilities like Semaphore, ReEntrantLock, CountdownLatch extend the aforementioned class. 
Worker class needs to override only few methods, to get the desired locking (for its state).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Worker</span>
        <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span>
        <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
  
     <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">isHeldExclusively</span><span class="o">()</span> <span class="o">{</span>
         <span class="k">return</span> <span class="nf">getState</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">;</span>
     <span class="o">}</span>
    
     <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">{</span>
             <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
             <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
     <span class="o">}</span>
    
     <span class="kd">protected</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
         <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
     <span class="o">}</span>
    
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span>        <span class="o">{</span> <span class="n">acquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">tryLock</span><span class="o">()</span>  <span class="o">{</span> <span class="k">return</span> <span class="n">tryAcquire</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
     <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span>      <span class="o">{</span> <span class="n">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="o">}</span>
<span class="o">}</span>    </code></pre></figure>

<h2 id="executor-shutdown-with-states">Executor shutdown (with states)</h2>

<p>When a shutdown is requested for the executor,</p>

<ul>
  <li>it changes its state to SHUTDOWN/STOP to stop accepting new tasks</li>
  <li>changes it state to TIDYING</li>
  <li>tries to shut all running threads (on best-effort-basis)</li>
  <li>changes its state to TERMINATED</li>
  <li>if shutdownNow is called, returns the list of pending tasks</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for shutDown</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">checkShutdownAccess</span><span class="o">();</span>
    <span class="n">advanceRunState</span><span class="o">(</span><span class="no">SHUTDOWN</span><span class="o">);</span> <span class="c1">// change state to SHUTDOWN</span>
    <span class="n">interruptIdleWorkers</span><span class="o">();</span>
    <span class="n">onShutdown</span><span class="o">();</span> <span class="c1">// hook for ScheduledThreadPoolExecutor</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// partial code for shutDownNow</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdownNow</span><span class="o">()</span> <span class="o">{</span>
    
    <span class="c1">// ... code same as shutdown...</span>
     <span class="n">advanceRunState</span><span class="o">(</span><span class="no">STOP</span><span class="o">);</span> <span class="c1">// change state to STOP</span>

    <span class="c1">// return pending tasks from the queue </span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">tasks</span> <span class="o">=</span> <span class="n">drainQueue</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tasks</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// partial code for tryTerminate</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">tryTerminate</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">interruptIdleWorkers</span><span class="o">();</span>
    <span class="n">terminated</span><span class="o">();</span>
    <span class="n">termination</span><span class="o">.</span><span class="na">signalAll</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<h2 id="thread-interrupts">Thread Interrupts</h2>

<p>When the executor is shutdown, it will change its state and ask all threads to interrupt. 
Note that worker threads run the tasks using its lock, thus executor cannot interrupt such threads. 
It can only interrupt threads which are idle.</p>

<p>The worker threads before starting to execute the tasks, check the state of the executor, 
and interrupt the thread.</p>

<p>Thus stopping the executor is on a best effort basis. Any threads which are running long 
running tasks might take a while to respond to interrupt (or to complete the task).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">interruptIdleWorkers</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">onlyOne</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span> <span class="o">:</span> <span class="n">workers</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">thread</span><span class="o">;</span>
        
        <span class="c1">// if worker not already interrupted, try to acquire its lock</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">t</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="na">tryLock</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// interrupt the thread</span>
                <span class="n">t</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SecurityException</span> <span class="n">ignore</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">w</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// partial code of runWorker</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">runWorker</span><span class="o">(</span><span class="nc">Worker</span> <span class="n">w</span><span class="o">){</span>
 <span class="k">if</span> <span class="o">((</span><span class="n">runStateAtLeast</span><span class="o">(</span><span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="no">STOP</span><span class="o">)))</span>
    <span class="n">wt</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<h2 id="default-thread-factory-executors">Default thread factory (Executors)</h2>

<p>The default thread factory, creates non-daemon threads, with same priority as calling thread (or Normal priority if not set)
and sets appropriate names for the threads to distinguish between threads of different pools.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">static</span> <span class="kd">class</span> <span class="nc">DefaultThreadFactory</span> <span class="kd">implements</span> <span class="nc">ThreadFactory</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">poolNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">ThreadGroup</span> <span class="n">group</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">threadNumber</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">namePrefix</span><span class="o">;</span>

    <span class="nc">DefaultThreadFactory</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">SecurityManager</span> <span class="n">s</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">();</span>
        <span class="n">group</span> <span class="o">=</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="n">s</span><span class="o">.</span><span class="na">getThreadGroup</span><span class="o">()</span> <span class="o">:</span>
                              <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getThreadGroup</span><span class="o">();</span>
        <span class="n">namePrefix</span> <span class="o">=</span> <span class="s">"pool-"</span> <span class="o">+</span>
                      <span class="n">poolNumber</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">()</span> <span class="o">+</span>
                     <span class="s">"-thread-"</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Thread</span> <span class="nf">newThread</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">group</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span>
                              <span class="n">namePrefix</span> <span class="o">+</span> <span class="n">threadNumber</span><span class="o">.</span><span class="na">getAndIncrement</span><span class="o">(),</span>
                              <span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">isDaemon</span><span class="o">())</span>
            <span class="n">t</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">getPriority</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">)</span>
            <span class="n">t</span><span class="o">.</span><span class="na">setPriority</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">NORM_PRIORITY</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="types-of-executors">Types of executors</h2>

<p>Now that we understand how task queue, keepAlive time, thread factory, corePoolSize and maxPoolSize are used by the executor,  creating various types of Executors is easy.</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Meaning</th>
      <th>Min Threads</th>
      <th>Max Threads</th>
      <th>Queue type</th>
      <th>keepAlive</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Fixed</td>
      <td>Fixed size of worker threads</td>
      <td>x</td>
      <td>x</td>
      <td>LinkedBlockingQueue</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Single</td>
      <td>Single worker thread</td>
      <td>1</td>
      <td>1</td>
      <td>LinkedBlockingQueue</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Cached</td>
      <td>Unlimited max threads</td>
      <td>x</td>
      <td>Integer.MAX_VALUE</td>
      <td>SynchronousQueue</td>
      <td>60 seconds</td>
    </tr>
    <tr>
      <td>Scheduled</td>
      <td>For scheduled tasks</td>
      <td>x</td>
      <td>Integer.MAX_VALUE</td>
      <td>DelayedWorkQueue</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>There is also an WorkStealingPool which uses <a href="https://github.com/openjdk-mirror/jdk/blob/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent/ForkJoinPool.java">ForkJoinPool</a>, that is a separate class not covered in this post.</p>

<h2 id="conclusion">Conclusion</h2>

<p>~2000 lines of code for ThreadPoolExecutor class looks overwhelming at first. 
Though, if we start with only the essentials and 
keep adding each layer, it all starts to make sense. Dare I say, the code looks quite straight-forward. 
There is a sense of elegance and beauty in its simplicity.</p>

<p>We have not covered <a href="https://github.com/openjdk-mirror/jdk/blob/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent/FutureTask.java">FutureTask</a> and <a href="https://github.com/openjdk-mirror/jdk/blob/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent/ForkJoinPool.java">ForkJoinPool</a>. Those demand their own blog post.</p>

<p>Hit me up in the comments for any queries or corrections.</p>
:ET