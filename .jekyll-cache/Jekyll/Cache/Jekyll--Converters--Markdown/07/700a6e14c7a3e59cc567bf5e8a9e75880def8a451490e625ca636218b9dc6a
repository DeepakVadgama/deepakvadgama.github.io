I"“m<h2 id="introduction">Introduction</h2>

<p>While reading source code of ArrayBlockingQueue implementation, I found this rather intriguing snippet of code.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">ArrayBlockingQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">items</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">[</span><span class="n">capacity</span><span class="o">];</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">(</span><span class="n">fair</span><span class="o">);</span>  <span class="c1">// Intriguing</span>
    <span class="n">notEmpty</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="n">notFull</span> <span class="o">=</span>  <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p>What!? Thatâ€™s it? Either <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code> for a lock decides fairness of all blocking queue operations?
 Letâ€™s find out what makes a ReentrantLock so special. Itâ€™s source code can be found <a href="https://github.com/openjdk-mirror/jdk/tree/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent/locks">here</a>.</p>

<h2 id="table-of-contents">Table of contents</h2>

<ul>
  <li><a href="#reentrantlock---aqs">ReentrantLock &amp; AQS</a></li>
  <li><a href="#locking">Locking</a>
    <ul>
      <li><a href="#basic-locking">Basic locking</a></li>
      <li><a href="#algorithm-for-concurrent-access">Algorithm for concurrent access</a></li>
      <li><a href="#fair-acquire">Fair acquire</a></li>
      <li><a href="#add-to-the-fifo-queue">Add to the FIFO queue</a></li>
      <li><a href="#node-exclusivity">Node Exclusivity</a></li>
      <li><a href="#barging">Barging</a></li>
      <li><a href="#unfair-acquire">Unfair acquire</a></li>
    </ul>
  </li>
  <li><a href="#unlock">Unlocking</a>
    <ul>
      <li><a href="#basic-unlocking">Basic unlocking</a></li>
      <li><a href="#when-thread-is-reentrant">When thread is reentrant</a></li>
      <li><a href="#what-about-queued-threads">What about queued threads</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="reentrantlock--aqs">ReentrantLock &amp; AQS</h2>

<p>It turns out ReentrantLock creates 2 helper classes extending <code class="highlighter-rouge">AbstractQueuedSynchronizer</code>, and delegates all locking operations including the fairness.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// default is unfair sync</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">ReentrantLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="nc">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">NonfairSync</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">abstract</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Sync</span> <span class="kd">extends</span> <span class="nc">AbstractQueuedSynchronizer</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="nc">Sync</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">NonfairSync</span> <span class="kd">extends</span> <span class="nc">Sync</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// delegate lock</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// delegate release</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Also, the class <code class="highlighter-rouge">AbstractQueueSynchronizer</code> aka <code class="highlighter-rouge">AQS</code> seems to be used by most locks in Java.</p>

<figure>
    <a href="https://deepakvadgama.com/images/blog/AQS_uses.png"><img src="https://deepakvadgama.com/images/blog/AQS_uses.png" /></a>
</figure>

<p>Let us try to understand the code. This code walk through is not sequential nor atomic (per method). In each subsequent step, we will add one feature or address a problem.</p>

<h2 id="locking">Locking</h2>

<h3 id="basic-locking">Basic locking</h3>

<p>Locking means exclusive access. Integer variable called <code class="highlighter-rouge">state</code> is used to maintain this access. Value of 0 means the state is unlocked, while value of 1 or more means state is locked by 1 or more threads. Using integer variable is better because it allows use of single-instruction <a href="https://en.wikipedia.org/wiki/Compare-and-swap">compare-and-swap operations</a>.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">state</span><span class="o">;</span>   <span class="c1">// value of 0 = unlocked, &gt;0 = locked</span>

<span class="c1">// basic lock acquire</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// if state = 0, update the state to 1 and set the current thread as owner i.e. acquire the lock</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)){</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
<span class="o">}</span></code></pre></figure>

<h3 id="algorithm-for-concurrent-access">Algorithm for concurrent access</h3>

<p>For locking operation, if lock is already being used, the basic algorithm is to enqueue the thread and block.
Similarly for unlock operation, release the lock (reset the state) and unblock first queued thread.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="o">*</span> <span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;</span>
 <span class="o">*</span> <span class="nl">Acquire:</span>
 <span class="o">*</span>     <span class="k">while</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
 <span class="o">*</span>        <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">enqueue</span> <span class="n">thread</span> <span class="k">if</span> <span class="n">it</span> <span class="n">is</span> <span class="n">not</span> <span class="n">already</span> <span class="n">queued</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;;</span>
 <span class="o">*</span>        <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">possibly</span> <span class="n">block</span> <span class="n">current</span> <span class="n">thread</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;;</span>
 <span class="o">*</span>     <span class="o">}</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="nl">Release:</span>
 <span class="o">*</span>     <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
 <span class="o">*</span>        <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">unblock</span> <span class="n">the</span> <span class="n">first</span> <span class="n">queued</span> <span class="n">thread</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;;</span>
 <span class="o">*</span> <span class="o">&lt;/</span><span class="n">pre</span><span class="o">&gt;</span></code></pre></figure>

<h3 id="fair-acquire">Fair acquire</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// try to acquire the lock, if unable to do so, enqueue the thread.</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// partial code</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">addWaiter</span><span class="o">(</span><span class="nc">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// fair Sync acquire</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// if state = 0 (unlocked), and if no threads are queued (waiting to acquire a lock)</span>
        <span class="c1">// then reset the state and acquire the lock</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">hasQueuedPredecessors</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
            <span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// if current thread itself is the owner of the lock,</span>
    <span class="c1">// then update the state value (in case of ReentrantLock, add 1) and continue</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">;</span>
        <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// else return false so that this thread can be then added to the wait queue</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="add-to-the-fifo-queue">Add to the FIFO queue</h3>

<p>If the <code class="highlighter-rouge">tryAcquire</code> fails, then add the thread to the queue and block it until
the lock is released and it is at head of the queue (all earlier threads are removed from the queue).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nc">Node</span> <span class="nf">addWaiter</span><span class="o">(</span><span class="nc">Node</span> <span class="n">mode</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// create a new node with current thread</span>
    <span class="nc">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">(),</span> <span class="n">mode</span><span class="o">);</span>
    <span class="c1">// try the fast path of enqueue; backup to full enq on failure</span>
    <span class="nc">Node</span> <span class="n">pred</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">node</span><span class="o">.</span><span class="na">prev</span> <span class="o">=</span> <span class="n">pred</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetTail</span><span class="o">(</span><span class="n">pred</span><span class="o">,</span> <span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">pred</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// full enqueue</span>
    <span class="n">enq</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<p>Note that the actual queue used a variation on the standard queue we know.
Lets not go into details of it now. If interested, you can read about it <a href="https://github.com/openjdk-mirror/jdk/blob/adea42765ae4e7117c3f0e2d618d5e6aed44ced2/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L301">here</a>.</p>

<h3 id="node-exclusivity">Node Exclusivity</h3>

<p>You may have noticed <code class="highlighter-rouge">Node.EXCLUSIVE</code> in the code snippet above.
This is easy to understand if we understand its sibling <code class="highlighter-rouge">Node.SHARED</code>.
Shared node is used for read locks where multiple threads can simultaneously have access to the lock.
In most cases we use <code class="highlighter-rouge">Node.EXCLUSIVE</code>, especially in our context of <code class="highlighter-rouge">ReentrantLock</code> where-in we need exclusive access by a single thread.</p>

<h3 id="barging">Barging</h3>

<p>Now that we understand how queues are used, lets look at what is <code class="highlighter-rouge">Barging</code>.</p>

<p>Lets revisit the snippet of code.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// unfair Sync partial code</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// don't care about the potential queued threads</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">());</span>
<span class="o">}</span></code></pre></figure>

<p>Suppose the state was just unlocked, and there are few threads waiting in the queue.
But, suddenly a new thread tries to acquire the lock, and it does not check the waiting-thread-queue. It acquires the lock, unfairly ahead of all waiting threads i.e. <code class="highlighter-rouge">Barging</code>.</p>

<h3 id="unfair-acquire">Unfair acquire</h3>

<p>Unfair acquire is almost same, except, it again tries to barge in without checking the wait-thread-queue.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// unfair Sync partial code</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">nonfairTryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// don't bother with state of the queue</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">acquires</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// rest is same as fair tryAndAcquire</span>
<span class="o">}</span></code></pre></figure>

<h2 id="unlock">Unlock</h2>

<h3 id="basic-unlocking">Basic unlocking</h3>

<p>Now that the thread owns a lock, unlocking/releasing it is simple.
Reset the state and remove thread as lock owner.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">sync</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// partial, modified code for both fair/unfair sync</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">setState</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// reset the state</span>
    <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// remove the ownership</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="when-thread-is-reentrant">When thread is reentrant</h3>

<p>When the thread has acquired the lock multiple times (i.e. Reentrant), we reduce the state value by 1 each time
the thread calls unlock/release. This is because thread is expected to call unlock same number of times as lock.
Thus, in this case, the state cannot be set to 0, and ownership is still retained by the thread.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code for both fair/unfair sync</span>
<span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// update the state (in case of ReentrantLock, subtract 1)</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="c1">// if state = 0 (unlocked), only then remove ownership.</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">free</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// update the state</span>
    <span class="n">setState</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="what-about-queued-threads">What about queued threads</h3>

<p>If there are threads waiting to acquire the lock, we need to <code class="highlighter-rouge">unpark</code> the thread at head of the queue (thread that has waited the longest).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">release</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// if lock was successfully released, remove a waiting thread from queue</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">tryRelease</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
        <span class="nc">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
        <span class="c1">// if queue is not empty (i.e. head is not null) and</span>
        <span class="c1">// wait status = 0 (default value, other values are for Condition and such)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">unpark</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// partial and updated code for unpark</span>
<span class="c1">// i.e. remove the node from the queue and wake it up (so that it can acquire the lock)</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">unpark</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="no">UNSAFE</span><span class="o">.</span><span class="na">unpark</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">thread</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>Note: The actual code unparks nodeâ€™s successor instead of node itself. This is because, during acquire, immediately after adding node to the queue, it tries again to acquire the lock for the head node. We skipped that part to retain simplicity. You can checkout the <a href="https://github.com/openjdk-mirror/jdk/blob/adea42765ae4e7117c3f0e2d618d5e6aed44ced2/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L857">acquire</a> and <a href="https://github.com/openjdk-mirror/jdk/blob/adea42765ae4e7117c3f0e2d618d5e6aed44ced2/src/share/classes/java/util/concurrent/locks/AbstractQueuedSynchronizer.java#L638">unpark</a> code for more details.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I was putting off going through this code for a long time. It turned out to be a wonderful ride.
We skipped some important parts of the code like <code class="highlighter-rouge">Condition</code> object, doAcquireInterruptibly, Cancelled status and lot more. But hopefully, now that we understand the basics, it will be easier to unpack.</p>

<p>Hats off to the original author of the code, Doug Lea. It is relatively easy to understand (considering its complex functionality) and the documentation for these classes is the most comprehensive and informative Iâ€™ve ever encountered.</p>

<p>Hit me up in the comments for any queries or corrections.</p>
:ET