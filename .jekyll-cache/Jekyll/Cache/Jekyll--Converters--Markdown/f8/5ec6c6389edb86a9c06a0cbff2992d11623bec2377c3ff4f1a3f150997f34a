I"òó<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#core-logic">Core logic</a>
    <ul>
      <li><a href="#chained-calls">Chained calls</a></li>
      <li><a href="#executors">Executors</a></li>
      <li><a href="#types">Types</a></li>
      <li><a href="#asyncsupply">AsyncSupply</a></li>
      <li><a href="#setting-the-result">Setting the result</a></li>
      <li><a href="#other-chained-methods">Chained methods</a></li>
      <li><a href="#running-the-chained-methods">Running the chained methods</a></li>
    </ul>
  </li>
  <li><a href="#other-apis">Other APIs</a>
    <ul>
      <li><a href="#manual-complete">Manual Complete</a></li>
      <li><a href="#cancel">Cancel</a></li>
    </ul>
  </li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>In Java, it has always been easy to execute a task in separate thread using Runnable/Callable. It helps in offloading task off the main thread (eg: In Android, network requests are not allowed be executed in a UI thread).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Runnable</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Runnable</span><span class="o">(){</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Want to run this in separate thread."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span></code></pre></figure>

<p>With <code class="highlighter-rouge">ExecutorService</code>, it is even easier to manage multiple independent tasks in separate a thread/thread-pool.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// 10 threads executing 100 tasks.</span>
<span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Executing task"</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">}</span></code></pre></figure>

<p>Though, if we want to execute multiple related/dependant tasks one after another, 
the flow is not completely asynchronous. It is because the future.get method (which is used to wait for a task to be completed) is a blocking operation.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&gt;</span> <span class="n">companies</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Future</span><span class="o">&gt;();</span>

<span class="nc">ExecutorService</span> <span class="n">executorService</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="nc">Future</span> <span class="n">future</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="k">new</span> <span class="nc">CompanyTickerTask</span><span class="o">(</span><span class="n">companyNames</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="n">companies</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">future</span><span class="o">);</span>
<span class="o">}</span>

<span class="k">for</span><span class="o">(</span><span class="nc">Future</span> <span class="n">future</span> <span class="o">:</span> <span class="n">companies</span><span class="o">){</span>
    <span class="c1">// blocking operations performed in order of futures stored in the list </span>
    <span class="c1">// instead of futures which are completed </span>
    <span class="nc">String</span> <span class="n">companyTicker</span> <span class="o">=</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>  <span class="c1">// blocking</span>
    <span class="n">executorService</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">StockPriceTask</span><span class="o">(</span><span class="n">companyTicker</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// skipping boiler plate defining task classes  </span></code></pre></figure>

<figure style="border: 1px solid gray">
    <a href="https://deepakvadgama.com/images/blog/completable_future.png" data-lightbox="image-1"><img src="https://deepakvadgama.com/images/blog/completable_future.png" /></a>
</figure>

<p>This is exactly the use-case <code class="highlighter-rouge">CompletableFuture</code> was built for; to chain multiple dependant tasks. 
It is very similar to JavaScript Promises which helps chain call-back methods (aka tasks).</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">getStockInfo</span><span class="o">(</span><span class="err">‚Äú</span><span class="no">GOOGL</span><span class="err">‚Äù</span><span class="o">))</span>   <span class="c1">// executed in a thread-pool </span>
        <span class="o">.</span><span class="na">thenApplyAsync</span><span class="o">(</span><span class="nl">Stock:</span><span class="o">:</span><span class="n">getRate</span><span class="o">)</span>   <span class="c1">// callback method once above lambda (getStockInfo) is completed</span>
        <span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="n">rate</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">rate</span><span class="o">))</span> 
        <span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="err">‚Äú</span><span class="n">done</span><span class="err">‚Äù</span><span class="o">)));</span></code></pre></figure>

<p>Another way to think of it is Java Streams where each step can be executed in async manner (in a separate thread). 
You can explore more about CompletableFuture in <a href="https://www.youtube.com/watch?v=Q_0_1mKTlnY">this talk</a>.</p>

<p>Now that we understand its use case, let‚Äôs walk-through its <a href="https://github.com/openjdk-mirror/jdk/blob/jdk8u/jdk8u/master/src/share/classes/java/util/concurrent/CompletableFuture.java">source code</a>.</p>

<h2 id="core-logic">Core logic</h2>

<h3 id="chained-calls">Chained calls</h3>

<p>The USP of this class is chained calls (aka fluid API). For this to work, each call should return 
instance of a <code class="highlighter-rouge">CompletableFuture</code> so that same methods can be again applied on the return type.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="nc">CompletableFuture</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="nc">Executor</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Supplier</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// create new instance </span>
    <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;();</span>
    
    <span class="c1">// execute the task on an executor</span>
    <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">AsyncSupply</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">f</span><span class="o">));</span>
    
    <span class="c1">// return the instance to allow chained calls</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">;</span> 
<span class="o">}</span></code></pre></figure>

<h3 id="executors">Executors</h3>

<p>The compute methods have 2 versions,</p>

<ul>
  <li>one which takes ExecutorService instance as an argument to run the task.</li>
  <li>one which only supplies the task, and CompletableFuture uses its own ExecutorService to run it.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Default executor</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Executor</span> <span class="n">asyncPool</span> <span class="o">=</span> <span class="n">useCommonPool</span> <span class="o">?</span>
    <span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">ThreadPerTaskExecutor</span><span class="o">();</span>

<span class="c1">// Fallback if ForkJoinPool.commonPool() cannot support parallelism</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ThreadPerTaskExecutor</span> <span class="kd">implements</span> <span class="nc">Executor</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r</span><span class="o">).</span><span class="na">start</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Use own thread-pool </span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="n">asyncPool</span><span class="o">,</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// Use externally supplied thread-pool</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<h3 id="types">Types</h3>

<p>There are 4 types of primary/compute calls supported.</p>

<ul>
  <li><strong>Supply</strong>: Used to supply value. No input, provides output.</li>
  <li><strong>Apply</strong>: Used to apply a function on an input. Takes input, provides output.</li>
  <li><strong>Accept</strong>: Used to accept a value and run a function using the same. Takes input, doesn‚Äôt provide output.</li>
  <li><strong>Run</strong>: Used to run a function. No input, no output.</li>
</ul>

<p>Each of these are represented as classes: <code class="highlighter-rouge">AsyncSupply</code>, <code class="highlighter-rouge">UniApply</code>, <code class="highlighter-rouge">UniAccept</code> and <code class="highlighter-rouge">UniRun</code>.</p>

<h3 id="asyncsupply">AsyncSupply</h3>

<p>Lets start with <code class="highlighter-rouge">CompletableFuture.supplyAsync</code>. It is responsible for</p>

<ul>
  <li>executing the supplied task</li>
  <li>setting the result value or exception or null (in case its a Run method which doesn‚Äôt have any output)</li>
  <li>calling the postComplete method so that next CompletableFuture can be called</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// the public method which uses default thread-pool (which is instance of ForkJoin default pool)</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="n">asyncPool</span><span class="o">,</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// the public method which uses supplied thread-pool</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span> <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="nc">Executor</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// create a new instance to return</span>
    <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;();</span>
    
    <span class="c1">// submit the applied function to the thread-pool</span>
    <span class="n">e</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">AsyncSupply</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;(</span><span class="n">d</span><span class="o">,</span> <span class="n">f</span><span class="o">));</span>
    
    <span class="c1">// return the instance so that chained call can be triggered</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Partial code from actual class</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">AsyncSupply</span> <span class="kd">extends</span> <span class="nc">ForkJoinTask</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// run the supplied function and get the value</span>
            <span class="nc">Value</span> <span class="n">val</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">run</span><span class="o">();</span>
            
            <span class="c1">// set the CompletableFuture value </span>
            <span class="c1">// to be used by next CompletableFuture in the chain as input</span>
            <span class="n">d</span><span class="o">.</span><span class="na">completeValue</span><span class="o">(</span><span class="n">val</span><span class="o">);</span>
            
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// set the value as exception </span>
            <span class="n">d</span><span class="o">.</span><span class="na">completeThrowable</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="c1">// call the postcomplete which triggers the the next task (callback method) in the chain</span>
        <span class="n">d</span><span class="o">.</span><span class="na">postComplete</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="setting-the-result">Setting the result</h3>

<p>The result of a function (output) if any, is applied to a single field using CAS (compare-and-swap) operation. 
This set result is then used by subsequent CompletableFutures as input</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Completes with a non-exceptional result, unless already completed</span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">completeValue</span><span class="o">(</span><span class="no">T</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="no">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">RESULT</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="no">NIL</span> <span class="o">:</span> <span class="n">t</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// null results are wrapped</span>
<span class="kd">static</span> <span class="kd">final</span> <span class="nc">AltResult</span> <span class="no">NIL</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AltResult</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="c1">// Exceptions within the CompletableFuture are also set in same method </span>
<span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">completeThrowable</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="no">UNSAFE</span><span class="o">.</span><span class="na">compareAndSwapObject</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="no">RESULT</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">encodeThrowable</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
<span class="o">}</span>
<span class="kd">static</span> <span class="nc">AltResult</span> <span class="nf">encodeThrowable</span><span class="o">(</span><span class="nc">Throwable</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">AltResult</span><span class="o">((</span><span class="n">x</span> <span class="k">instanceof</span> <span class="nc">CompletionException</span><span class="o">)</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">CompletionException</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
<span class="o">}</span></code></pre></figure>

<h3 id="other-chained-methods">Other chained methods</h3>

<p>The other chained methods (thenApply, thenAccept, thenRun) are slightly different than the <code class="highlighter-rouge">supply</code> method.
They are very similar to each other though. Lets take a look at one of them, say <code class="highlighter-rouge">thenApplyAsync</code> method.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">thenApplyAsync</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">fn</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">uniApplyStage</span><span class="o">(</span><span class="n">asyncPool</span><span class="o">,</span> <span class="n">fn</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nf">uniApplyStage</span><span class="o">(</span><span class="nc">Executor</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">V</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span>  <span class="k">new</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;();</span>
    
    <span class="c1">// check if previous CompletableFuture is already completed. </span>
    <span class="c1">// if yes, just run the apply function and return the instance of this CompletableFuture</span>
    <span class="c1">// if no, get inside if</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">d</span><span class="o">.</span><span class="na">uniApply</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
    
        <span class="c1">// create instance of UniApply with source and dependant CFs and the function to apply.</span>
        <span class="nc">UniApply</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UniApply</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span><span class="no">V</span><span class="o">&gt;(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="n">f</span><span class="o">);</span>
        
        <span class="c1">// push the instance on stack so that it can be popped and run later</span>
        <span class="n">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        
        <span class="c1">// again check if its prior future is completed, if so apply the function </span>
        <span class="n">c</span><span class="o">.</span><span class="na">tryFire</span><span class="o">(</span><span class="no">SYNC</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// return the instance to run chained methods.</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// partial code </span>
<span class="kd">final</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="kt">boolean</span> <span class="nf">uniApply</span><span class="o">(</span><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">,</span>
                           <span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">S</span><span class="o">,?</span> <span class="kd">extends</span> <span class="no">T</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">,</span>
                           <span class="nc">UniApply</span><span class="o">&lt;</span><span class="no">S</span><span class="o">,</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">r</span><span class="o">;</span> <span class="nc">Throwable</span> <span class="n">x</span><span class="o">;</span>
    
    <span class="c1">// if prior result is not completed (a.result) return false. </span>
    <span class="k">if</span> <span class="o">((</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">result</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        
    <span class="c1">// if result is completed</span>
    <span class="nl">tryComplete:</span> <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="c1">// if the set result is an Exception, there is no point in going on, </span>
        <span class="c1">// just call the completeThrowable again and return</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="k">instanceof</span> <span class="nc">AltResult</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">x</span> <span class="o">=</span> <span class="o">((</span><span class="nc">AltResult</span><span class="o">)</span><span class="n">r</span><span class="o">).</span><span class="na">ex</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">completeThrowable</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
                <span class="k">break</span> <span class="n">tryComplete</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">r</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// use the set result as input to our function f, apply the function, </span>
        <span class="c1">// and call completeValue with the result (output)</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="no">S</span> <span class="n">s</span> <span class="o">=</span> <span class="o">(</span><span class="no">S</span><span class="o">)</span> <span class="n">r</span><span class="o">;</span>
            <span class="n">completeValue</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// if there is an exception, same drill, call completeThrowable</span>
            <span class="n">completeThrowable</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="running-the-chained-methods">Running the chained methods</h3>

<p>Notice that the CompletableFuture dependencies are only added to the stack if the previous ones are not completed yet.
In such cases, the stack has to be popped one after other, and run.</p>

<p>Lets revisit the <code class="highlighter-rouge">postComplete</code> method from the AsyncSupply‚Äôs run method.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// partial code</span>
<span class="kd">final</span> <span class="kt">void</span> <span class="nf">postComplete</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// On each step, variable f holds current dependents to pop and run. </span>
    <span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="k">this</span><span class="o">;</span> <span class="nc">Completion</span> <span class="n">h</span><span class="o">;</span>
    
    <span class="c1">// until stack is empty</span>
    <span class="k">while</span> <span class="o">((</span><span class="n">h</span> <span class="o">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">=</span> <span class="k">this</span><span class="o">).</span><span class="na">stack</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">CompletableFuture</span><span class="o">&lt;?&gt;</span> <span class="n">d</span><span class="o">;</span> <span class="nc">Completion</span> <span class="n">t</span><span class="o">;</span>
        
        <span class="c1">// change head of the stack to next node</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">casStack</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">))</span> <span class="o">{</span>
            <span class="c1">// run the function for the CompletableFuture (whatever it may be)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="o">(</span><span class="n">d</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">tryFire</span><span class="o">(</span><span class="no">NESTED</span><span class="o">))</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="k">this</span> <span class="o">:</span> <span class="n">d</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="other-apis">Other APIs</h2>

<h3 id="manual-complete">Manual Complete</h3>

<p><code class="highlighter-rouge">CompletableFuture</code> also exposes a public method to manually set the value from the outside.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">complete</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// same method seen before, called directly with the result value</span>
    <span class="kt">boolean</span> <span class="n">triggered</span> <span class="o">=</span> <span class="n">completeValue</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    
    <span class="c1">// call the postComplete method so that dependant CFs can be called. </span>
    <span class="n">postComplete</span><span class="o">();</span>
    
    <span class="k">return</span> <span class="n">triggered</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h3 id="cancel">Cancel</h3>

<p>Similarly it also allows a CF instance to be cancelled manually.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">cancel</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">mayInterruptIfRunning</span><span class="o">)</span> <span class="o">{</span>
    
    <span class="c1">// wrap cancel exception in a result wrapper</span>
    <span class="nc">AltResult</span> <span class="n">theResult</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AltResult</span><span class="o">(</span><span class="k">new</span> <span class="nc">CancellationException</span><span class="o">());</span>
    
    <span class="c1">// set it only if result is not already set</span>
    <span class="kt">boolean</span> <span class="n">cancelled</span> <span class="o">=</span> <span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">internalComplete</span><span class="o">(</span><span class="n">theResult</span><span class="o">);</span>
    
    <span class="c1">// trigger postComplete so that dependant CFs can be called</span>
    <span class="n">postComplete</span><span class="o">();</span>
    
    <span class="k">return</span> <span class="n">cancelled</span> <span class="o">||</span> <span class="n">isCancelled</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<h2 id="conclusion">Conclusion</h2>

<p><code class="highlighter-rouge">CompletableFuture</code> class source is ~2400 lines long. It also has massive API. 
Also, sadly, of all the JDK source classes I‚Äôve read, this one was the most difficult to understand. 
Anyways, it was satisfying to finally <em>get</em> it.</p>

<p>We skipped all teh compound methods which uses multiple CompletableFuture instances in combinations of and, or, any etc. 
Though, hopefully, once you get the basic flow detailed above, the rest should come relatively easy.</p>

<p>Hit me up in the comments for any queries or corrections.</p>
:ET